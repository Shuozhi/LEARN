OPPO提前批面试：
突然发现C/C++的一个关键。C++有啥特殊性呢？还不就是贴近底层，这就是它的特点也是它的优势。那我怎么可以忽略内存管理方面的知识呢？！现在开始学吧！

C语言知识整理（3）：内存管理（详细版）：
https://www.cnblogs.com/yif1991/p/5049638.html


C++变量类型：
       基本类型
                int
                double
                ...
       复合类型
                引用
                指针
                const
       标准库类型
                string
                vector
                迭代器
                pair
       内置数组
                一维数组
                多维数组



操作系统：

1）用户态切换到内核态的3种方式  
a. 系统调用  
这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 
系统调用实质上是一个中断，而汇编指令int 就可以实现用户态向内核态切换，iret实现内核态向用户态切换  
b. 异常  
当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。  
c. 外围设备的中断  
当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。   
这3种方式是系统在运行时由用户态转到内核态的最主要方式，

其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。   

2）具体的切换操作  
从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括：  
[1] 从当前进程的描述符中提取其内核栈的ss0及esp0信息。  
[2] 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个  
过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一  
条指令。  
[3] 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始  
执行中断处理程序，这时就转到了内核态的程序执行了。

(55）源代码到可执行文件过程
.c文件经过编译器、汇编器之后得到目标文件.o，目标文件再与库进行链接得到可执行文件.out。 
库其实就是一组目标文件的打包，这些目标文件中都是一些常用的代码。
看操作系统笔记本第三章

